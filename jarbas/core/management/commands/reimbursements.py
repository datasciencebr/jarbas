import pandas as pd

from jarbas.core.management.commands import LoadCommand
from jarbas.core.models import Reimbursement


class Command(LoadCommand):
    help = 'Load Serenata de Amor reimbursements dataset'

    def add_arguments(self, parser):
        super().add_arguments(parser)
        parser.add_argument(
            '--batch-size', '-b', dest='batch_size', type=int, default=10000,
            help='Number of documents to be created at a time (default: 10000)'
            )

        parser.add_argument(
            dest='irregularities_path',
            help='Path to irregularities dataset')

    def handle(self, *args, **options):
        self.reimbursements_path = options['dataset']
        self.irregularities_path = options['irregularities_path']
        self.count = Reimbursement.objects.count()
        print('Starting with {:,} reimbursements'.format(self.count))

        if options.get('drop', False):
            self.drop_all(Reimbursement)
            self.count = 0

        self.bulk_create_by(self.reimbursements, options['batch_size'])
        self.print_count(Reimbursement, count=self.count, permanent=True)

    @property
    def reimbursements(self):
        """Returns a Generator with a Reimbursement object for each row."""
        print('Reading reimbursements dataset…')
        reimbursements = pd.read_csv(self.reimbursements_path, dtype=object).fillna('')
        
        print('Reading irregularities dataset…')
        irregularities = pd.read_csv(self.irregularities_path, dtype=object).fillna('')
        
        print('Merging datasets…')
        on = ('applicant_id', 'year', 'document_id')
        
        for _, row in pd.merge(reimbursements, irregularities, on=on).iterrows():
            yield Reimbursement(**self.serialize(row.to_dict()))

    def serialize(self, reimbursement):
        """Read the dict generated by DictReader and fix content types"""
        
        if 'probability' in reimbursement:
            reimbursement['probability'] = float(reimbursement['probability'])
        else:
            reimbursement['probability'] = None
        
        suspicions_keys = (
                'over_monthly_subquota_limit',
                'meal_price_outlier', 
                'suspicious_traveled_speed_day'
                )
        
        suspicions = {}
        for key in suspicions_keys:
            if key in reimbursement:
                suspicions[key] = self.bool(reimbursement[key])
                del reimbursement[key]
        
        reimbursement['suspicions'] = suspicions or None

        rename = (
            ('subquota_number', 'subquota_id'),
            ('reimbursement_value_total', 'total_reimbursement_value')
            )
        for old, new in rename:
            reimbursement[new] = reimbursement[old]
            del reimbursement[old]

        integers = (
            'applicant_id',
            'batch_number',
            'congressperson_document',
            'congressperson_id',
            'document_id',
            'document_type',
            'installment',
            'month',
            'subquota_group_id',
            'subquota_id',
            'term',
            'term_id',
            'year'
        )
        for key in integers:
            reimbursement[key] = self.to_number(reimbursement[key], int)

        floats = (
            'document_value',
            'remark_value',
            'total_net_value',
            'total_reimbursement_value'
        )
        for key in floats:
            reimbursement[key] = self.to_number(reimbursement[key])

        reimbursement['issue_date'] = self.to_date(reimbursement['issue_date'])

        return reimbursement

    def bulk_create_by(self, reimbursements, size):
        batch = list()
        for reimbursement in reimbursements:
            batch.append(reimbursement)
            if len(batch) == size:
                self.bulk_create(batch)
                batch = list()
        self.bulk_create(batch)

    def bulk_create(self, batch):
        Reimbursement.objects.bulk_create(batch)
        self.count += len(batch)
        self.print_count(Reimbursement, count=self.count)
    
    @staticmethod
    def bool(string):
        if string.lower() in ('false', '0', '0.0', 'none', 'nil', 'null'):
            string = ''
        return bool(string)
